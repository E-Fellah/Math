from manim import *
import numpy as np

# --- 1. Global Configuration ---
config.background_color = WHITE 
config.stroke_color = BLACK
config.fill_color = BLACK

class MathProblemSolverTemplate(Scene):
    def construct(self):
        # --- 1. Geometry & Layout Setup ---
        UPPER_FRACTION = 4/5 
        LOWER_FRACTION = 1/5
        total_width = config.frame_width
        total_height = config.frame_height
        upper_height = total_height * UPPER_FRACTION
        lower_height = total_height * LOWER_FRACTION
        upper_box_width = total_width / 2 - 0.1
        
        # Padding & Scaling Factors
        PADDING_FACTOR = 0.95
        NUMBER_FRACTION = 1/8  
        TEXT_FRACTION = 7/8    
        
        # Gap between bottom containers (same as original design)
        BOTTOM_GAP = 0.1
        
        # --- UI Containers ---
        bottom_y_center = DOWN * (total_height * (0.5 - LOWER_FRACTION/2))
        upper_y_center = UP * (total_height * (0.5 - UPPER_FRACTION/2))

        # Create top containers first
        # Top Left: Formula/Input (MathTex ONLY container)
        self.left_box = Rectangle(
            width=upper_box_width,  height=upper_height - 0.1,   
            color=BLUE_A, stroke_color=BLUE_D, fill_opacity=0.05
        ).move_to(upper_y_center + LEFT * total_width / 4)
        
        # Top Right: Visual/Graph (Manim Objects ONLY container)
        self.right_box = Rectangle(
            width=upper_box_width, height=upper_height - 0.1,
            color=RED_A, stroke_color=RED_D, fill_opacity=0.05
        ).move_to(upper_y_center + RIGHT * total_width / 4)

        # Calculate the actual left edge position of the left_box
        left_box_left_edge = self.left_box.get_left()[0]
        right_box_right_edge = self.right_box.get_right()[0]
        
        # Calculate available width for bottom containers (minus gap)
        available_bottom_width = right_box_right_edge - left_box_left_edge - BOTTOM_GAP
        
        # Bottom Left: ID/Counter - Align left edge with left_box
        bottom_left_width = available_bottom_width * NUMBER_FRACTION
        bottom_left_x = left_box_left_edge + (bottom_left_width / 2)
        self.bottom_left_box = Rectangle(
            width=bottom_left_width,  
            height=lower_height - 0.1, 
            color=GREEN_A, stroke_color=GREEN_D, fill_opacity=0.1
        ).move_to([bottom_left_x, bottom_y_center[1], 0])
        
        # Bottom Right: Explanation/Commentary - Align right edge with right_box
        bottom_right_width = available_bottom_width * TEXT_FRACTION
        bottom_right_x = right_box_right_edge - (bottom_right_width / 2)
        self.bottom_right_box = Rectangle(
            width=bottom_right_width,  
            height=lower_height - 0.1, 
            color=GREEN_A, stroke_color=GREEN_D, fill_opacity=0.05
        ).move_to([bottom_right_x, bottom_y_center[1], 0])

        # Max Dimensions for scaling
        self.max_upper_width = self.left_box.width * PADDING_FACTOR
        self.max_upper_height = self.left_box.height * PADDING_FACTOR
        self.max_comment_width = self.bottom_right_box.width * PADDING_FACTOR
        self.max_comment_height = self.bottom_right_box.height * PADDING_FACTOR

        # --- 2. Logic: Directly display the example ---
        # Example math problem with proper format
        current_submission = {
            "id": "1",
            "math_tex": [
                # LEFT CONTAINER: MathTex objects only
                MathTex(r"1+1", color=BLACK),
                MathTex(r"= 2", color=BLACK).next_to(MathTex(r"1+1"), RIGHT)
            ],
            "visuals": [
                # RIGHT CONTAINER: Will be created dynamically in display_problem
            ],
            "explanation": "Visual representation of addition using circles.\nOne circle plus one circle equals two circles."
        }

        self.display_problem(current_submission)

    def create_alignment_grid(self, container, grid_spacing=0.5):
        """Create a subtle alignment grid for a container, similar to MS Word's grid"""
        grid = VGroup()
        
        # Get container dimensions and position
        width = container.width * 0.95  # Slightly smaller than container
        height = container.height * 0.95
        center = container.get_center()
        
        # Create vertical grid lines
        num_vertical = int(width / grid_spacing)
        for i in range(-num_vertical//2, num_vertical//2 + 1):
            x_pos = i * grid_spacing
            line = Line(
                start=center + UP * height/2 + RIGHT * x_pos,
                end=center + DOWN * height/2 + RIGHT * x_pos,
                color=GRAY_E,  # Very light gray
                stroke_width=0.5,
                stroke_opacity=0.2  # Very subtle
            )
            grid.add(line)
        
        # Create horizontal grid lines
        num_horizontal = int(height / grid_spacing)
        for i in range(-num_horizontal//2, num_horizontal//2 + 1):
            y_pos = i * grid_spacing
            line = Line(
                start=center + LEFT * width/2 + UP * y_pos,
                end=center + RIGHT * width/2 + UP * y_pos,
                color=GRAY_E,
                stroke_width=0.5,
                stroke_opacity=0.2
            )
            grid.add(line)
        
        # Add center crosshair for alignment
        center_cross = VGroup(
            Line(
                start=center + LEFT * 0.3,
                end=center + RIGHT * 0.3,
                color=GRAY_D,
                stroke_width=1,
                stroke_opacity=0.3
            ),
            Line(
                start=center + DOWN * 0.3,
                end=center + UP * 0.3,
                color=GRAY_D,
                stroke_width=1,
                stroke_opacity=0.3
            )
        )
        grid.add(center_cross)
        
        return grid

    def display_problem(self, data):
        # Create Boxes
        self.play(map(Create, [self.left_box, self.right_box, self.bottom_left_box, self.bottom_right_box]))

        # Create alignment grids for left and right containers
        left_grid = self.create_alignment_grid(self.left_box, grid_spacing=0.3)
        right_grid = self.create_alignment_grid(self.right_box, grid_spacing=0.3)
        
        # Add grids to containers (fade them in very subtly)
        self.play(FadeIn(left_grid, run_time=0.5, lag_ratio=0.1, rate_func=rate_functions.ease_in_out_sine))
        self.play(FadeIn(right_grid, run_time=0.5, lag_ratio=0.1, rate_func=rate_functions.ease_in_out_sine))

        # A. ID Box
        id_text = Text(str(data["id"]), color=BLACK, font_size=36).move_to(self.bottom_left_box)
        
        # B. Math Box (Left) - MathTex objects ONLY
        math_group = VGroup(*data["math_tex"])
        # Center and scale math content
        math_group.arrange(RIGHT, buff=0.5)
        if math_group.width > self.max_upper_width or math_group.height > self.max_upper_height:
            math_group.scale_to_fit_width(self.max_upper_width * 0.8)
        math_group.move_to(self.left_box)
        
        # C. Visual Box (Right) - Animated circles demonstration
        # Get the center cross from the right grid to align our animation
        center_cross = right_grid[-1]
        cross_center = center_cross.get_center()
        
        # Create circles at positions relative to the cross center
        # Left circle (first "1")
        left_circle = Circle(
            radius=0.4,
            color=BLUE_D,
            stroke_width=3,
            fill_opacity=0.2,
            fill_color=BLUE_A
        ).move_to(cross_center + LEFT * 1.5)
        
        left_label = Text("1", color=BLACK, font_size=24).next_to(left_circle, DOWN, buff=0.2)
        
        # Plus sign
        plus_sign = Text("+", color=BLACK, font_size=36).move_to(cross_center + LEFT * 0.5)
        
        # Right circle (second "1")
        right_circle = Circle(
            radius=0.4,
            color=RED_D,
            stroke_width=3,
            fill_opacity=0.2,
            fill_color=RED_A
        ).move_to(cross_center + RIGHT * 0.5)
        
        right_label = Text("1", color=BLACK, font_size=24).next_to(right_circle, DOWN, buff=0.2)
        
        # Equals sign
        equals_sign = Text("=", color=BLACK, font_size=36).move_to(cross_center + RIGHT * 1.5)
        
        # Result circles (the "2")
        result_circle1 = Circle(
            radius=0.4,
            color=GREEN_D,
            stroke_width=3,
            fill_opacity=0.2,
            fill_color=GREEN_A
        ).move_to(cross_center + RIGHT * 2.5 + UP * 0.5)
        
        result_circle2 = Circle(
            radius=0.4,
            color=PURPLE_D,
            stroke_width=3,
            fill_opacity=0.2,
            fill_color=PURPLE_A
        ).move_to(cross_center + RIGHT * 2.5 + DOWN * 0.5)
        
        result_label = Text("2", color=BLACK, font_size=24).next_to(result_circle2, DOWN, buff=0.2)
        
        # Group all visual elements
        visual_group = VGroup(
            left_circle, left_label,
            plus_sign,
            right_circle, right_label,
            equals_sign,
            result_circle1, result_circle2, result_label
        )
        
        # Scale visual group to fit if needed
        if visual_group.width > self.max_upper_width or visual_group.height > self.max_upper_height:
            visual_group.scale_to_fit_width(self.max_upper_width * 0.9)
            visual_group.scale_to_fit_height(self.max_upper_height * 0.9)
        visual_group.move_to(self.right_box)

        # D. Explanation (Bottom Right) - Fixed font size 24, max 2 lines
        # Split explanation into lines, limit to 2 lines
        explanation_lines = data["explanation"].split('\n')[:2]
        
        # Create explanation text with fixed font size
        expl = VGroup()
        for i, line in enumerate(explanation_lines):
            line_text = Text(line, color=BLACK, font_size=24)
            line_text.shift(DOWN * i * 0.5)  # Line spacing
            expl.add(line_text)
        
        # Center the explanation group vertically
        expl.arrange(DOWN, center=False, aligned_edge=LEFT)
        expl.move_to(self.bottom_right_box)
        
        # Scale if too wide (but keep font size fixed by scaling group)
        if expl.width > self.max_comment_width:
            expl.scale_to_fit_width(self.max_comment_width * 0.9)
        
        # Position to align with left edge of container
        expl.align_to(self.bottom_right_box.get_left(), LEFT)
        expl.shift(RIGHT * 0.2)

        # Animate in order
        self.play(Write(id_text))
        self.play(Write(math_group))
        
        # Animate the circles step by step
        # Step 1: First circle
        self.play(Create(left_circle), Write(left_label))
        self.wait(0.5)
        
        # Step 2: Plus sign
        self.play(Write(plus_sign))
        self.wait(0.5)
        
        # Step 3: Second circle
        self.play(Create(right_circle), Write(right_label))
        self.wait(0.5)
        
        # Step 4: Equals sign
        self.play(Write(equals_sign))
        self.wait(0.5)
        
        # Step 5: Result circles
        self.play(
            Create(result_circle1),
            Create(result_circle2),
            Write(result_label)
        )
        self.wait(1)
        
        # Step 6: Show the explanation
        self.play(Write(expl))
        
        # Final wait
        self.wait(3)
