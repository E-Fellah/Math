from manim import *
import numpy as np

# --- 1. Global Configuration ---
config.background_color = WHITE 
config.stroke_color = BLACK
config.fill_color = BLACK

class ReadyToUseMathScript(Scene):
    def construct(self):
        # --- 1. Geometry & Layout Setup ---
        UPPER_FRACTION = 4/5 
        LOWER_FRACTION = 1/5
        total_width = config.frame_width
        total_height = config.frame_height
        upper_height = total_height * UPPER_FRACTION
        lower_height = total_height * LOWER_FRACTION
        upper_box_width = total_width / 2 - 0.1
        
        # Grid configuration
        self.grid_spacing = 0.5  # Spacing between grid points
        self.grid_visible = True  # Toggle for grid visibility
        
        # Padding & Scaling Factors
        PADDING_FACTOR = 0.95
        NUMBER_FRACTION = 1/8  
        TEXT_FRACTION = 7/8    
        
        # Gap between bottom containers
        BOTTOM_GAP = 0.1
        
        # --- UI Containers ---
        bottom_y_center = DOWN * (total_height * (0.5 - LOWER_FRACTION/2))
        upper_y_center = UP * (total_height * (0.5 - UPPER_FRACTION/2))

        # Create top containers first
        # Top Left: Math Formulas
        self.left_box = Rectangle(
            width=upper_box_width,  height=upper_height - 0.1,   
            color=BLUE_A, stroke_color=BLUE_D, fill_opacity=0.05
        ).move_to(upper_y_center + LEFT * total_width / 4)
        
        # Top Right: Visual/Graph (empty for now)
        self.right_box = Rectangle(
            width=upper_box_width, height=upper_height - 0.1,
            color=RED_A, stroke_color=RED_D, fill_opacity=0.05
        ).move_to(upper_y_center + RIGHT * total_width / 4)

        # Calculate the actual left edge position of the left_box
        left_box_left_edge = self.left_box.get_left()[0]
        right_box_right_edge = self.right_box.get_right()[0]
        
        # Calculate available width for bottom containers (minus gap)
        available_bottom_width = right_box_right_edge - left_box_left_edge - BOTTOM_GAP
        
        # Bottom Left: Chapter Counter
        bottom_left_width = available_bottom_width * NUMBER_FRACTION
        bottom_left_x = left_box_left_edge + (bottom_left_width / 2)
        self.bottom_left_box = Rectangle(
            width=bottom_left_width,  
            height=lower_height - 0.1, 
            color=GREEN_A, stroke_color=GREEN_D, fill_opacity=0.1
        ).move_to([bottom_left_x, bottom_y_center[1], 0])
        
        # Bottom Right: Explanation
        bottom_right_width = available_bottom_width * TEXT_FRACTION
        bottom_right_x = right_box_right_edge - (bottom_right_width / 2)
        self.bottom_right_box = Rectangle(
            width=bottom_right_width,  
            height=lower_height - 0.1, 
            color=GREEN_A, stroke_color=GREEN_D, fill_opacity=0.05
        ).move_to([bottom_right_x, bottom_y_center[1], 0])

        # Max Dimensions for scaling
        self.max_upper_width = self.left_box.width * PADDING_FACTOR
        self.max_upper_height = self.left_box.height * PADDING_FACTOR
        self.max_comment_width = self.bottom_right_box.width * PADDING_FACTOR
        self.max_comment_height = self.bottom_right_box.height * PADDING_FACTOR

        # Font sizes
        self.commentary_font_size = 24  # Fixed size for explanations
        self.title_font_size = 20  # Two steps smaller than comment (24 -> 22 -> 20)
        self.numbering_font_size = 36   # Size for chapter counter

        # --- Display boxes first ---
        title = Tex(r"\textbf{Ready-to-use Math Script}", font_size=64, color=BLACK)
        self.play(Write(title))
        self.wait(1.5)
        self.play(
            FadeOut(title),
            Create(self.left_box),
            Create(self.right_box),
            Create(self.bottom_left_box),
            Create(self.bottom_right_box)
        )

        # --- Create functional coordinate grids for top containers ---
        left_grid = self.create_coordinate_grid(self.left_box, self.grid_spacing)
        right_grid = self.create_coordinate_grid(self.right_box, self.grid_spacing)
        
        # Add coordinate systems to containers
        if self.grid_visible:
            self.play(
                FadeIn(left_grid, run_time=0.5),
                FadeIn(right_grid, run_time=0.5)
            )
        
        # Store grids for later use
        self.left_grid = left_grid
        self.right_grid = right_grid
        self.left_grid_points = self.extract_grid_points(self.left_box, self.grid_spacing)
        self.right_grid_points = self.extract_grid_points(self.right_box, self.grid_spacing)
        
        # --- 2. Display Single Example ---
        
        # Display chapter title
        chap_title = Text("Basic Arithmetic", font_size=self.title_font_size, color=BLACK)
        chap_title.to_corner(UP + LEFT).shift(RIGHT * 0.15 + DOWN * 0.2)
        
        # Ensure title stays within left container horizontally
        left_boundary = self.left_box.get_left()[0] + 0.05
        if chap_title.get_left()[0] < left_boundary:
            chap_title.shift(RIGHT * (left_boundary - chap_title.get_left()[0]))
        
        self.play(FadeIn(chap_title))
        
        # --- Left Container: Static Math Formula ---
        math_formula = MathTex(r"1 + 1 = 2", color=BLACK)
        
        # Scale to fit container
        if math_formula.width > self.max_upper_width or math_formula.height > self.max_upper_height:
            scale_factor = min(
                self.max_upper_width * 0.8 / math_formula.width,
                self.max_upper_height * 0.8 / math_formula.height
            )
            math_formula.scale(scale_factor)
        
        # Hang at specific grid coordinates (center)
        math_formula, actual_coords = self.hang_at_coordinates(
            math_formula, self.left_box, 0, 0
        )
        
        # --- Bottom Left: Chapter Counter ---
        num_mob = Text("1/1", font_size=self.numbering_font_size, color=BLACK)
        num_mob.move_to(self.bottom_left_box)
        
        # --- Bottom Right: Explanation ---
        explanation_text = "Visualizing basic addition.\nOne object plus one object equals two objects."
        explanation_lines = explanation_text.split('\n')[:2]
        expl = VGroup()
        for i, line in enumerate(explanation_lines):
            line_text = Text(line, color=BLACK, font_size=self.commentary_font_size)
            line_text.shift(DOWN * i * 0.6)
            expl.add(line_text)
        
        expl.arrange(DOWN, center=False, aligned_edge=LEFT)
        expl.move_to(self.bottom_right_box)
        
        if expl.width > self.max_comment_width:
            expl.scale_to_fit_width(self.max_comment_width * 0.9)
        
        expl.align_to(self.bottom_right_box.get_left(), LEFT)
        expl.shift(RIGHT * 0.2)
        
        # --- Animate left container and bottom containers ---
        self.play(
            Write(math_formula),
            Write(num_mob),
            Write(expl)
        )
        
        # --- Right Container: Animated Dots ---
        # Create compact animation in the right container
        right_center = self.right_box.get_center()
        
        # Create dots with minimal spread
        dot1 = Dot(color=BLUE, radius=0.12)
        dot2 = Dot(color=BLUE, radius=0.12)
        dot3 = Dot(color=GREEN, radius=0.12)
        dot4 = Dot(color=GREEN, radius=0.12)
        
        # Position dots in a compact arrangement
        # First group: left side (1 + 1)
        dot1.move_to(right_center + LEFT * 1.2 + UP * 0.2)
        dot2.move_to(right_center + LEFT * 0.4 + UP * 0.2)
        
        # Second group: right side (= 2)
        dot3.move_to(right_center + RIGHT * 0.4 + UP * 0.2)
        dot4.move_to(right_center + RIGHT * 1.0 + UP * 0.2)
        
        # Create operators
        plus = Text("+", font_size=36, color=BLACK)
        equals = Text("=", font_size=36, color=BLACK)
        plus.move_to(right_center + LEFT * 0.8 + UP * 0.2)
        equals.move_to(right_center + RIGHT * 0.0 + UP * 0.2)
        
        # Animation sequence
        self.wait(1)
        
        # Show first dot
        self.play(FadeIn(dot1))
        self.wait(0.5)
        
        # Show plus sign
        self.play(FadeIn(plus))
        self.wait(0.5)
        
        # Show second dot
        self.play(FadeIn(dot2))
        self.wait(0.5)
        
        # Show equals sign
        self.play(FadeIn(equals))
        self.wait(0.5)
        
        # Show result dots (both at once)
        self.play(
            FadeIn(dot3),
            FadeIn(dot4)
        )
        
        # Add labels to clarify
        label1 = Text("1", font_size=24, color=BLACK).next_to(dot1, DOWN, buff=0.1)
        label2 = Text("1", font_size=24, color=BLACK).next_to(dot2, DOWN, buff=0.1)
        label3 = Text("2", font_size=24, color=BLACK).next_to(dot3, DOWN, buff=0.1)
        
        self.wait(1)
        self.play(
            Write(label1),
            Write(label2),
            Write(label3)
        )
        
        self.wait(2)
        
        # --- Cleanup ---
        self.play(
            FadeOut(chap_title),
            FadeOut(math_formula),
            FadeOut(num_mob),
            FadeOut(expl),
            FadeOut(dot1), FadeOut(dot2), FadeOut(dot3), FadeOut(dot4),
            FadeOut(plus), FadeOut(equals),
            FadeOut(label1), FadeOut(label2), FadeOut(label3)
        )

        # Final fade out
        self.play(FadeOut(self.left_box, self.right_box, self.bottom_left_box, self.bottom_right_box))
        self.play(FadeOut(self.left_grid, self.right_grid))
        self.wait(1)

    def create_coordinate_grid(self, container, spacing=0.5):
        """Create a functional coordinate grid with snapping points"""
        grid = VGroup()
        
        # Get container dimensions and position
        width = container.width * 0.95
        height = container.height * 0.95
        center = container.get_center()
        
        # Calculate number of grid points
        num_x = int(width / spacing)
        num_y = int(height / spacing)
        
        # Create grid lines
        # Vertical lines
        for i in range(-num_x//2, num_x//2 + 1):
            x_pos = i * spacing
            line = Line(
                start=center + UP * height/2 + RIGHT * x_pos,
                end=center + DOWN * height/2 + RIGHT * x_pos,
                color=GRAY_D,
                stroke_width=0.8,
                stroke_opacity=0.15
            )
            grid.add(line)
        
        # Horizontal lines
        for i in range(-num_y//2, num_y//2 + 1):
            y_pos = i * spacing
            line = Line(
                start=center + LEFT * width/2 + UP * y_pos,
                end=center + RIGHT * width/2 + UP * y_pos,
                color=GRAY_D,
                stroke_width=0.8,
                stroke_opacity=0.15
            )
            grid.add(line)
        
        # Create grid intersection points (small dots for snapping)
        for i in range(-num_x//2, num_x//2 + 1):
            for j in range(-num_y//2, num_y//2 + 1):
                x_pos = i * spacing
                y_pos = j * spacing
                
                # Create a small dot at intersection
                dot = Dot(
                    point=center + RIGHT * x_pos + UP * y_pos,
                    radius=0.02,
                    color=BLUE_E,
                    fill_opacity=0.4
                )
                grid.add(dot)
        
        # Add center axes for reference
        x_axis = Line(
            start=center + LEFT * width/2,
            end=center + RIGHT * width/2,
            color=RED_D,
            stroke_width=1.5,
            stroke_opacity=0.3
        )
        y_axis = Line(
            start=center + DOWN * height/2,
            end=center + UP * height/2,
            color=RED_D,
            stroke_width=1.5,
            stroke_opacity=0.3
        )
        grid.add(x_axis, y_axis)
        
        # Add center crosshair
        center_cross = VGroup(
            Line(
                start=center + LEFT * 0.15,
                end=center + RIGHT * 0.15,
                color=RED_D,
                stroke_width=2,
                stroke_opacity=0.5
            ),
            Line(
                start=center + DOWN * 0.15,
                end=center + UP * 0.15,
                color=RED_D,
                stroke_width=2,
                stroke_opacity=0.5
            )
        )
        grid.add(center_cross)
        
        return grid

    def extract_grid_points(self, container, spacing):
        """Extract all grid point coordinates for snapping"""
        width = container.width * 0.95
        height = container.height * 0.95
        center = container.get_center()
        
        num_x = int(width / spacing)
        num_y = int(height / spacing)
        
        grid_points = []
        for i in range(-num_x//2, num_x//2 + 1):
            for j in range(-num_y//2, num_y//2 + 1):
                x_pos = i * spacing
                y_pos = j * spacing
                point = center + RIGHT * x_pos + UP * y_pos
                grid_points.append({
                    'coords': (i, j),  # Grid coordinates
                    'position': point,  # Actual position
                    'x': x_pos,
                    'y': y_pos
                })
        
        return grid_points

    def hang_at_coordinates(self, mobject, container, grid_x, grid_y):
        """Place an object at specific grid coordinates"""
        if container == self.left_box:
            grid_points = self.left_grid_points
        else:
            grid_points = self.right_grid_points
        
        # Find point with given coordinates
        for point in grid_points:
            if point['coords'] == (grid_x, grid_y):
                mobject.move_to(point['position'])
                return mobject, point['coords']
        
        # If exact coordinates not found, return centered
        mobject.move_to(container.get_center())
        return mobject, (0, 0)
